#!/bin/bash

# This script will rotate the internal display and pen/touch input devices
# on the Lenovo ThinkPad Helix.
#
# Possible arguments are:
#
#  normal (or none)
#  right (or cw)
#  inverted (or half or flip)
#  left (or ccw)
#
# Script orignally from http://forum.thinkpads.com/viewtopic.php?p=676101 
# Subsequently, it was edited and improved by: 
#      Martin Ueding <dev@martin-ueding.de>
#      Derek Ruths <druths@networkdynamics.org>
#      ultraviolet <ultravioletnanokitty@gmail.com>

set -e

#
# Static options
#

# The name of the output for the internal display
output_name="eDP1" # output used by the ThinkPad Helix's LCD

# The xinput name of the touch digitiser
touch_name="Atmel Atmel maXTouch Digitizer touch"

# The rotation to toggle to if current orientation is specified
toggle_rotation="normal"

# Define pre/post rotate hook locations
prerotate_hook="$HOME/.config/thinkpad-helix-utils/prerotate.sh"
postrotate_hook="$HOME/.config/thinkpad-helix-utils/postrotate.sh"

# Import the configuration file if there is one. This will replace any options set above.
configfile="$HOME/.config/thinkpad-helix-utils/config"

if [[ -f "$configfile" ]]; then
	source "$configfile"
fi

#
# determine current orientation
#

# Find the line in ``xrandr -q --verbose`` output that contains current screen orientation and strip out extraneous info
orientation="$(xrandr -q --verbose | grep 'connected' | grep "$internal" | egrep -o  '\) (normal|left|inverted|right) \(' | egrep -o '(normal|left|inverted|right)')"

echo "Current orientation is $orientation."

#
# set new rotation
#

# Execute pre-rotate hook
if [[ -f "$prerotate_hook" ]]; then
	echo "Executing pre-rotate hook..."
    "$prerotate_hook"
fi

args=$@
if [[ ${#args[@]} > 0 ]]; then
	rotation=${args[0]}
fi

if [[ -n "$rotation" ]]; then
	# If the specified state is the current one, toggle to specified orientation. This enables toggling rotation with one command.
	if [[ "$orientation" = "$rotation" ]]; then
		echo "Current orientation specified, reverting to $toggle_rotation."
		rotation=$toggle_rotation
	else
		echo "Setting screen orientation to $rotation."
	fi
else
	# No options were specified. Cycle orientations by default.
	case "$orientation" in
		normal)
			rotation=right
			;;
		right)
			rotation=inverted
			;;
		inverted)
			rotation=left 
			;;
		left)
			rotation=normal
			;;
	esac
	echo "No options specified, cycling to $rotation by default"
fi

# Translate directions into ``xrandr`` and ``xsetwacom`` names.
case "$rotation" in
	none|normal)
		xrandr_rotation=normal
		touch_rotation=(1 0 0 0 1 0 0 0 1)
		;;
	cw|right)
		xrandr_rotation=right
		touch_rotation=(0 1 0 -1 0 1 0 0 1)
		;;
	half|inverted|flip) 
		xrandr_rotation=inverted
		touch_rotation=(-1 0 1 0 -1 1 0 0 1) 
		;;
	ccw|left)
		xrandr_rotation=left
		touch_rotation=(0 -1 1 1 0 0 0 0 1)
		;;
	*)
		echo "Unknown direction: $rotation. Try normal, right, inverted, or left."
		exit 2
esac

echo "Rotating screen to $rotation"

# Rotate display
xrandr --output "$output_name" --rotate "$xrandr_rotation"

# Rotate capacitive digitiser
xinput set-prop "$touch_name" 'Coordinate Transformation Matrix' ${touch_rotation[@]}

# There's no need to rotate the Wacom devices - they rotate by default since they're managed by xinput.

# Execute post-rotate hook
if [[ -f "$postrotate_hook" ]]; then
	echo "Executing post-rotate hook..."
	"$postrotate_hook"
fi
exit
